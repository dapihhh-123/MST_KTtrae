下面是一份可以直接放进你项目文档里的 **Task Oracle 测试用例输入契约（Input Contract）**，目标是：**让 Runner 不需要猜参数结构，从而避免“万无一失”的歧义问题**。内容同时兼容 function / script / cli 三类 deliverable。

---

# Task Oracle Input Contract v1.0

## 1. 目的

统一测试用例中“输入”的表达方式，使 Runner 在执行评测时**不需要推断**“这是参数列表还是单参数值”，从而避免参数解包错误。

---

## 2. 核心约定

### 2.1 Function deliverable

对于 `deliverable_type = "function"`：

* 测试用例字段 `input` **永远表示位置参数列表（args）**。
* Runner 必须按以下方式调用：

  ```python
  got = fn(*test_case["input"])
  ```

#### 示例

* 两个参数函数：`summarize_logs(lines, last_n_errors)`

  ```json
  "input": [ ["log1", "log2"], 5 ]
  ```

  等价于：`summarize_logs(["log1","log2"], 5)`

* 单参数且参数本身是 list：`foo(nums: list[int])`

  ```json
  "input": [ [1,2,3] ]
  ```

  注意：外层仍然是 args 列表，内层是 list 参数值。
  等价于：`foo([1,2,3])`

* 单参数且参数是普通值：`bar(n: int)`

  ```json
  "input": [ 10 ]
  ```

  等价于：`bar(10)`

> **关键点**：外层永远是 args 列表，哪怕只有一个参数。

---

### 2.2 Script deliverable

对于 `deliverable_type = "script"`：

* `input` 表示脚本运行时的输入来源，必须使用结构化对象：

  ```json
  "input": {
    "stdin": "...\n...", 
    "files": { "filename.ext": "file content" }
  }
  ```
* Runner 执行方式（概念上）：

  * 将 `files` 写入沙箱工作目录
  * 将 `stdin` 作为标准输入喂给脚本
  * 捕获 stdout/stderr 和生成文件，用于断言 expected

#### 示例

```json
"input": {
  "stdin": "",
  "files": {
    "receipt.txt": "苹果 x2  7.50\nBANANA*1 3.2\n"
  }
}
```

---

### 2.3 CLI deliverable

对于 `deliverable_type = "cli"`：

* `input` 必须是结构化对象，包含命令行参数与输入：

  ```json
  "input": {
    "argv": ["--dir", "PATH", "--dry-run"],
    "stdin": "",
    "files": { "a.txt": "..." }
  }
  ```
* Runner 执行方式（概念上）：

  * 将 `files` 写入沙箱
  * 用 `argv` 作为命令行参数运行（模拟 `python tool.py ...`）
  * `stdin` 可选
  * 捕获 stdout/stderr 与退出码，用于对比 expected

#### 示例

```json
"input": {
  "argv": ["--in", "data.csv", "--out", "out.csv", "--col", "status", "--eq", "DONE"],
  "stdin": "",
  "files": {
    "data.csv": "id,status\n1,DONE\n2,TODO\n"
  }
}
```

---

## 3. Runner 端强校验（避免 silent guessing）

Runner 不应推断 input 类型，而应做**显式校验**并在测试用例不符合契约时返回“测试格式错误”。

### 3.1 Function 的校验

* 必须满足：`test_case["input"]` 是 list（args 列表）
* 进一步建议：对必需位置参数个数进行校验（可选但强烈推荐）

  * 若函数有 `N` 个必需位置参数，则 `len(input)` 必须等于 `N`
  * 不满足时：判为 “invalid_test_format” 并停止该测试执行（或直接整套报错）

> 这条校验能保证：即使 LLM 生成了不合规 tests，也不会让 runner “猜”从而产生隐蔽错误。

### 3.2 Script/CLI 的校验

* input 必须是 object
* script：允许 `stdin` 缺省，`files` 可缺省
* cli：`argv` 必须存在且为 list

---

## 4. 与现有 API 的映射（你当前接口不需要大改）

你当前返回的 `public_examples_preview[i].input` 已经在 function 场景使用了 args 列表（例如 `[lines_list, 10]`），只需要在文档中**明确它的含义就是 args**，并让 Runner **不要再包一层**。

---

## 5. 示例：本任务（日志统计器）应当如何表达

```json
{
  "name": "Basic summary",
  "input": [
    [
      "2026-02-07 13:20:11 | ERROR | auth | invalid token",
      "2026-02-07 13:20:12 | INFO | db | connected"
    ],
    10
  ],
  "expected": { "...": "..." }
}
```

---

## 6. 版本与兼容策略

* 从 `Input Contract v1.0` 起：Runner 必须按上述格式执行。
* 若旧数据存在不合规用例，Runner 应返回明确错误：

  * `invalid_test_format: function input must be args list`
  * `invalid_test_format: cli input must include argv`

---
