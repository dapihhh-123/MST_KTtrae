
---

# 一、观察采集层：详细任务清单（面向实现）

## 0) 目标与约束（先写进 README/注释里）

**目标**：在你的 IDE 项目中记录“会话级、事件级”的用户开发过程数据，形成可回放的结构化日志，供后续 PSW/诊断/LEAF/解锁使用。
**核心约束**：

* 日志要能 **按 session 回放时间线**
* 事件要 **追加写入、崩溃不丢**
* 事件字段要 **稳定（schema 固定）**
* 输出为 **纯文本可读（JSONL + summary）**

---

## 1) 数据模型与日志落盘（必须先做）

### 1.1 定义统一 Schema（TypeScript interface / JSON Schema 都可）

实现一个 `ObservationEvent` 总结构，至少支持这些事件类型：

* `session_start`, `session_end`
* `edit`（包含 paste / undo / redo / save 的区分）
* `snapshot`（至少 run/test 时保存；可选定时快照）
* `run_start`, `run_end`
* `test_start`, `test_end`（如果你把 test 和 run 分开）
* `lint_start`, `lint_end`（可选）
* `ai_event`（预留，后续用）
* `gate_event`（预留，后续用）

**通用字段（所有事件必须有）**

* `schema_version`（如 `"1.0"`）
* `event_id`（uuid）
* `timestamp`（ISO8601，带时区）
* `session_id`
* `task_id`（可为空，但字段要存在）
* `event_type`
* `source`（`frontend`/`backend`）
* `seq`（单 session 内单调递增序号，便于排序/补偿乱序）

### 1.2 设计存储格式（必须）

采用**每个 session 一个 JSONL 文件**（一行一个 JSON）：

* 路径建议：`logs/observations/<date>/<session_id>.jsonl`
* 可选：额外输出一个 `logs/observations/index.jsonl` 记录 session 元数据（便于检索）

### 1.3 实现日志写入器（必须）

实现一个 `ObservationLogger`：

* `append(event)`：追加写入 JSONL（确保换行、flush）
* **队列缓冲 + 定期 flush**（避免频繁 fs open/close）
* **进程退出钩子**：在退出/崩溃时尽量 flush
* **字段裁剪**：`stdout_snippet`、`error_message`、`stack_trace` 需要截断上限（例如 8KB），避免日志爆炸
* **敏感信息过滤**：至少过滤明显的 `OPENAI_API_KEY`/token 模式（简单正则即可）

---

## 2) Session / Task 元数据（第 1 类）

### 2.1 Session 生命周期（必须）

* 新建 session：生成 `session_id`
* 记录 `session_start` 事件（包含）

  * `task_id / task_text`（可为空但保留字段）
  * `language`
  * `run_command`
  * 是否有测试 `has_tests`
* 结束 session：记录 `session_end` 事件（包含 duration、事件计数）

### 2.2 “当前任务信息”接入点（必须）

如果你有任务面板/项目说明页：

* 在 session_start 写入 `task_text`（短文本）
  没有也没关系，但字段必须存在，后续方便补。

---

## 3) 编辑事件流 Edit Events（第 3 类，PSW 最关键之一）

在编辑器侧（Monaco/类似）实现事件采集：

### 3.1 捕获内容变更（必须）

监听 model content change，写入 `edit` 事件，至少包含：

* `changed_range`（startLine/startCol/endLine/endCol）
* `lines_added`, `lines_deleted`
* `chars_added`, `chars_deleted`（可选但很有用）
* `diff_summary`（可选：例如 `"+12 -3"`）
* `event_subtype`: `edit | paste | undo | redo`

  * `undo/redo`：利用编辑器事件标志（若无标志，用 command/快捷键 hook）
  * `paste`：若没有 paste hook，可用启发式：一次插入字符/行数超过阈值（如 >50 chars 或 >3 行）判为 paste

### 3.2 捕获保存事件（必须）

监听保存（或你系统的 Save 按钮），写 `edit` 事件：

* `event_subtype: save`
* 不需要 diff，但要记录时间

### 3.3 （可选）选择区/光标事件

如果你能拿到 selection change：

* 写 `cursor` 或 `selection` 事件（可选）
* 或者只在 snapshot 里记录 `cursor_line`、`selection_range`（建议至少做这个）

---

## 4) 代码快照 Snapshot（第 2 类，PSW 必需之一）

### 4.1 Run/Test 时强制快照（必须）

在 `run_start`/`test_start` 前，写入 `snapshot` 事件，字段：

* `file_content`（完整单文件文本）
* `cursor_line`
* `selection_range`
* `file_path`（如 `main.py`）

> PSW 最小可用：只要做到“每次运行前快照”就够。

### 4.2 （可选）定时快照

每隔 X 秒（如 30s/60s）写一次 snapshot（可后做）。

---

## 5) Run/Test 事件（第 4 类，PSW 最关键之二）

你的系统一定有“运行/执行”按钮或命令。把它包装成“可观测动作”。

### 5.1 Run 事件（必须）

* `run_start`: 记录 run_id、命令、工作目录
* 执行结束写 `run_end`：

  * `success`（exit code == 0）
  * `exit_code`
  * `stdout_snippet`（截断）
  * `stderr_snippet`（截断）
  * `duration_ms`

### 5.2 Test 事件（如果有测试，强烈建议）

如果你使用 pytest / jest / 自己的测试：

* `test_end` 字段：

  * `passed_count`, `failed_count`
  * `failed_tests`（列表，最多 N 条）
  * `success`（failed_count==0）

> 没有测试也没关系，先有 run；后续可以加“轻量样例验证”。

---

## 6) Error Trace（第 5 类，PSW/诊断都重要）

在 run/test 失败时，从 stderr 解析错误：

### 6.1 抽取标准字段（必须）

* `error_type`（例如 Python 的 `SyntaxError/TypeError/...`）
* `error_message`（截断）
* `stack_trace`（截断）
* `error_file`, `error_line`（至少要 line）

### 6.2 解析策略（必须达到“可用”）

* Python：从 traceback 最后一段提取 `File "...", line N` 和异常类型
* JS/TS：提取 `at ... (file:line:col)` 模式
* 如果解析失败：保留原始 stderr 到 `stack_trace_raw`，`error_line=null`

把这些字段放在 `run_end/test_end` 事件里，或单独写 `error` 事件都行，但要一致。

---

## 7) Static Signals（第 6 类，可选但建议预留字段）

你现在可先不实现 lint/AST，但最好把接口留好：

* `lint_end`: `lint_errors_count`, `lint_error_types`
* `static`: `missing_symbol`, `signature_match`

（后续你做诊断会很值。）

---

## 8) AI Interaction / Gate & Debt（第 7/8 类，先做“占位 + 可记录”）

你现在可能还没做理解解锁，但建议先把日志事件类型预留好，避免后面改 schema。

### 8.1 `ai_event`（预留）

字段：

* `trigger: psw|user`
* `leaf_level: L0-L4`
* `suggestion_id`
* `accepted: boolean`
* `post_accept_diff`（可为空）

### 8.2 `gate_event`（预留）

字段：

* `gate_type`（predict/locate/variant/complexity）
* `question`
* `answer`
* `pass_fail_skip`
* `debt_added/debt_repaid`

---

## 9) 调试工具与可验证性（必须，否则很难证明“采集正确”）

### 9.1 实现一个“日志自检脚本”（必须）

新增脚本：`tools/verify_observation_layer.py` 或 `tools/verify_observation_layer.ts`

功能：

1. 输入一个 `session_id` 或自动选择最新 session 日志
2. 逐行读取 JSONL，校验：

   * JSON 可解析
   * 必备字段存在（timestamp/session_id/event_type/seq）
   * seq 单调递增
3. 统计每种事件数量
4. 输出：

   * 首条/末条事件摘要
   * 是否存在 run->snapshot 配对（每次 run_start 前是否紧邻 snapshot）
   * 是否能从失败 run_end 中抽取 error_line/error_type
5. 最后打印 `PASS/FAIL` 和失败原因（纯文字）

### 9.2 实现一个“最小演示流程”（必须）

在仓库根目录提供说明（README 一段就行）：

* 如何开始一个 session
* 如何编辑文件触发 edit
* 如何 run 一次失败、再修复、再 run 成功
* 如何运行 verify 脚本得到文字报告

---

# 二、实现优先级（你可以让对方按这个顺序做）

**P0（支撑 PSW 的最小集合）**

1. JSONL Logger + session_start/end
2. edit（含 paste/undo/redo/save）
3. snapshot（至少 run 前）
4. run_start/end + error trace 解析
5. verify 工具（文字报告）

**P1（增强）**
6) test 解析（pytest/jest）
7) cursor/selection 更完整记录
8) lint/static signals

**P2（为后续机制铺路）**
9) ai_event、gate_event 占位与记录

---


# 三、针对本系统（Codellaborator + PSW/诊断/LEAF）的缺失补充

你现有清单覆盖了“通用 IDE 观察采集层”的大部分要点，但对照当前系统实现与机制触发链路，还缺少几类“必须记录/必须关联”的内容，建议补齐到观察采集层任务里。

## 10) 因果链与关联 ID（必须补齐，否则后续诊断/回放难闭环）

为保证“事件 → 触发诊断 → 策略决策 → 教学执行 → 用户采纳/修改 → 学习状态更新”可以被精确回放与归因，建议在事件体系里明确以下关联字段（可由前端生成，也可由后端补齐，但字段必须稳定存在）：

* `trace_id`：一次触发链路的关联 ID（例如一次 run/test/compile_error 或一次 gate 交互）
* `code_state_id` + `content_hash`：把“事件发生时的代码快照”与事件绑定（避免在 event.payload 里塞整段 code）
* `thread_id`/`breakout_thread_id`：事件发生的对话上下文（global / breakout）
* `ai_run_id`（可选但强烈建议）：一次 agent 输出（流式文本/编辑操作）的 run 标识
* `message_id`（可选）：流式消息合并的唯一标识，便于重建 UI 与采纳链路
* `client_ts`：前端采集时间戳（和后端 `created_at` 区分），用于排查网络/队列延迟
* `client_seq`：前端单 session 单调递增序号（用于乱序/重放），服务端可额外维护 `server_seq`

## 11) 事件类型补齐（与机制/界面强相关）

你清单里的事件类型更偏“编辑+运行”，但本系统还有几类与机制直接相关的观察事件需要纳入（至少预留 schema）：

* `compile`, `compile_error`：机制触发链路已依赖（用于 PSW/诊断）
* `idle`：已作为触发类型存在，建议明确字段（idle_ms、窗口前后编辑/运行计数）
* `cursor`, `selection`, `selection_dwell`：机制里强调“选中范围/停留”作为交互信号
* `breakout_create`, `breakout_open`, `breakout_close`：局部线程是核心教学载体，需要可回放
* `thread_toggle`（折叠/展开）、`thread_summary_generate`：用于解释用户的组织行为与复盘输出
* `highlight_spans_emit`、`intervention_plan_emit`、`ai_state_change`：属于“教学执行层的可见协作信号”
* `ai_message_begin`、`ai_text_chunk`（或等价的聚合事件）：至少要能重建 “什么时候开始写、写了多长、是否出错/中止”
* `ai_suggestion_shown`、`ai_suggestion_accept`、`ai_suggestion_reject`、`ai_suggestion_modify`：用于你机制里“采纳/修改比例（diff size）”特征
* `gate_present`、`gate_submit`：把理解解锁题目与用户回答纳入可回放结构，并与 debt/mastery 关联

## 12) 存储落地需要对齐本项目的数据面（DB 为主，JSONL 可导出）

你清单默认“每 session 一个 JSONL 文件”，但本系统当前以数据库表为主要存储（例如 EventLog/CodeState/CodeSnapshot/Thread/Message/AIStreamChunk 等）。建议把“观察采集层”的落地策略改为：

* **主存储**：写入数据库（便于联表回放、检索、机制实时读取）
* **可选导出**：提供 `export_session_jsonl(session_id)` 把 DB 聚合导出为 JSONL（满足“纯文本可读/可离线分析”的目标）

并在任务清单里明确一份映射（示例）：

* `ObservationEvent` → `EventLog`
* `snapshot` → `CodeSnapshot`（轻量 UI 恢复）+ `CodeState`（用于因果绑定/去重）
* `ai_event`/`gate_event` → `EventLog`（或单独表也可，但需能在 replay 聚合）
* Breakout/Thread/Message/Marker → 对应业务表（保证局部线程可回放）
* 流式文本/编辑操作 → `AIRun` + `AIStreamChunk` + `EditorOp`（或至少聚合保存到 EventLog）

## 13) Snapshot 内容与多文件支持（必须提前定边界）

当前清单把 `file_content` 作为单文件文本，但本系统存在 breakout anchor、marker 与高亮 spans，天然依赖“文件+范围”。建议补齐 snapshot 与 range 相关字段，避免后续 schema 反复改：

* `file_id`/`file_path`（哪怕 MVP 只有一个文件，也要留字段）
* `cursor_line/cursor_col`
* `selection_range`（start_line/start_col/end_line/end_col）
* `content_hash`（用于去重与引用 CodeState）
* （可选）`visible_range`（视窗行范围，帮助解释用户在看哪里）

## 14) 数据裁剪与敏感信息治理（必须）

你已有 stdout/stderr 截断建议，但对“代码/提示词/用户输入”还需要明确治理策略，避免后续数据不可用或不可分享：

* 对 `file_content`/`stderr`/`stdout` 做统一 size cap，并保留 `truncated: true/false`
* 统一做敏感信息过滤（KEY/token、明显的私密字符串）
* 默认不在 `EventLog.payload` 写入整段 code：用 `code_state_id` 引用，必要时才落 CodeState
* 对路径做规范化（相对路径/去机器用户名），提升跨机可复现性

## 15) 观测自检工具需要覆盖“机制闭环一致性”

你当前的 verify 关注 “JSON 可解析/字段存在/run-snapshot 配对”，建议再加几项“机制闭环一致性”检查（仍输出纯文字即可）：

* 每个触发事件（run/test/compile_error/idle）是否都有 `trace_id`
* 同一 `trace_id` 下是否能找到对应 `code_state_id`（或最近 snapshot）
* 若产生 intervention_plan：是否记录了 leaf_level/ceiling/unlock_required（可从事件或 run meta 取）
* 若产生 gate：是否记录了题目与用户回答，以及 debt/mastery 的变化（哪怕是占位字段）
* 若产生 breakout：是否能从 marker/thread anchor 回放到代码行范围



