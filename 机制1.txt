

---

# 完整机制：PSW-LEAF（基于有效挣扎窗口的自适应渐隐式教育代理）

## 0. 设计目标

在不显著降低完成效率的前提下，提高：

* **理解度**（能解释关键逻辑）
* **迁移能力**（隔天做变体仍能完成）
* **维护能力**（加需求/修 bug 不依赖 AI）

---

## 1. 系统总体架构（四层）

### A. 观察层（IDE Telemetry）

收集事件与特征（全部可工程实现）：

* 编辑：插入/删除频率、连续撤销、同一段反复改写、粘贴多行
* 调试：运行/测试次数、失败类型、错误栈位置变化
* 交互：选中代码范围、查看文档/注释、光标停留时间、idle
* 采纳：AI 建议被接受/修改比例、修改幅度（diff size）

### B. PSW 判定层（何时介入）

维护一个状态机：`In-PSW / Flailing / Stalling`

* **In-PSW（有效挣扎）**：编辑活跃且有方向（错误位置在移动、尝试有变化）
* **Flailing（乱试）**：短时间多次盲改 + 通过率下降（失败更频繁、错误更散）
* **Stalling（卡死）**：长时间 idle 或同一行重复删除重写、错误位置不动

输出：`NeedIntervene = {No / Yes}` + `State = {In-PSW/Flailing/Stalling}`

> 规则实现就够：例如 3 分钟内运行失败≥N 次且 diff 很小→Flailing；
> idle≥T 或同一段反复编辑≥K 次→Stalling。

### C. 诊断层（为什么介入）

当 `NeedIntervene=Yes`，对卡点进行四类归因：

1. **Recall Error**：语法/API/类型概念缺失（报错偏语法/属性不存在/类型不匹配）
2. **Adjustment Error**：照搬方案但参数/边界映射错（off-by-one、变量名错、维度错）
3. **Modification Error**：逻辑链路错（条件反了、循环不变量不成立）
4. **Decomposition Error**：不会拆解（无明显结构、空函数、乱写、无测试思路）

输出：`ErrorType ∈ {Recall, Adjustment, Modification, Decomposition}`

> 同样可用规则+LLM 辅助：
> 用错误栈/单测失败信息+最近 diff 摘要，让 LLM 做分类（并要求给出“证据片段”）。

### D. 教学执行层（怎么帮：LEAF）

用 **LEAF 的 5 级“脚手架阶梯”**作为动作空间，并引入**渐隐策略**：

帮助层级（从轻到重）：

* **L0 提问引导**（Socratic）：只问关键问题
* **L1 概念提示**（Hint）：提示思路/边界/数据结构
* **L2 骨架**（Skeleton）：函数结构+TODO
* **L3 局部补丁**（Patch）：补 3–10 行关键代码
* **L4 完整实现**（Full）：最终方案（受限制）

并维护一个学习状态 `Mastery(concept)`，决定**能给到的最高层级**与**是否需要理解锁**。

---

## 2. 核心策略：PSW + 诊断 → 限制 LEAF 输出（关键表）

### 2.1 介入时机策略（Timing）

* **In-PSW**：不打扰，只做“静默支持”

  * 仅允许：轻量高亮、显示“可求助按钮”、记录学习轨迹
* **Flailing / Stalling**：允许主动介入（弹出小提示条或局部线程）

### 2.2 错误类型到帮助上限（Backoff Ceiling）

| ErrorType     | 默认最高帮助层级 Ceiling | 典型输出           |
| ------------- | ---------------: | -------------- |
| Recall        |               L1 | API/语法提示 + 小例子 |
| Adjustment    |            L2~L3 | 提示参数映射→骨架/局部补丁 |
| Modification  |            L2~L3 | 逻辑检查点→骨架/局部补丁  |
| Decomposition |               L2 | 分解引导→骨架/伪代码    |

> 这一步是“反直给”的关键：**不是想写就写，而是被教育策略约束。**

### 2.3 渐隐（Fading）

* 若用户在某概念上连续 `R` 次在低层级（≤L1/L2）解决 → **下降一个 ceiling**
* 若连续失败 `F` 次或耗时过长 → **上升一个 ceiling**（但仍受最大限制）
* 每次任务结束做一次“掌握度更新”，用于下次更少帮助

---

## 3. “理解解锁”机制（防 Copy-Paste 的关键闭环）

当系统准备提供 **L3/L4**（会直接产生可运行代码）时，必须插入一个**检查点**：

### 3.1 检查点类型（任选其一，尽量 20–40 秒内回答）

* **预测型**：这段改动会影响什么测试？为什么？
* **定位型**：如果仍失败，最可能是哪条分支？
* **变体型**：如果输入包含 X 情况，需要改哪一步？
* **复杂度型**：时间复杂度/空间复杂度是多少？

### 3.2 解锁规则

* 答对/合理 → 允许显示并应用 L3/L4
* 答错 → 不给最终代码，退回 L2（骨架+提示）并解释错因
* 用户可点“跳过直给”（应急），但系统记录为**Learning Debt**：

  * 在下一个子任务边界强制给一个 30 秒复盘题（或让用户给一句话解释）

---

## 4. IDE 里的交互呈现（让它像“系统”而不是聊天机器人）

沿用 Codellaborator 的“可见协作”思路，把教育机制做成**低打扰的 IDE 原生体验**：

### 4.1 可见性

* AI 光标/状态（Thinking/Reviewing/Hinting）
* 新增/修改代码高亮标记来源
* 局部线程（贴在出错代码旁），避免全局聊天污染

### 4.2 低打扰介入形式（按 PSW 状态）

* In-PSW：仅在 gutter 显示一个小图标（“需要时点我”）
* Flailing：顶部轻提示条（1 行）+ 一键打开局部线程
* Stalling：局部线程直接出现一个 L0/L1 的问题（非常短）

---

## 5. 一次完整循环（你论文里可以画成流程图）

1. 用户编辑/运行测试
2. 系统更新 PSW 状态
3. 若 In-PSW：静默
4. 若 Flailing/Stalling：触发介入
5. 诊断错误类型（四分类）
6. 设定本次 ceiling（Backoff）
7. 从低到高尝试输出（L0→…→ceiling）
8. 若需 L3/L4：插入理解解锁
9. 用户解决/采纳后，更新 mastery
10. 子任务边界自动复盘（可选 1 句总结 + 1 个变体问题）

---

## 6. 你能写进论文的“贡献点”（很清晰）

* **PSW 作为介入时机控制**：减少打断、保护心流
* **四类诊断→教学策略约束**：让帮助“对症下药”
* **LEAF 分层脚手架+渐隐**：让系统随学习减少帮助
* **理解解锁+学习债务**：抑制盲验收，提高理解与所有权

---

## 7. 最小可实现版本（保证你能落地）

如果你担心实现量，我建议 MVP 这样做：

* PSW：纯规则（idle/失败次数/编辑模式）
* 诊断：LLM 分类（输入：错误栈+最近 diff+测试结果）
* Backoff：固定映射表（上面那张）
* LEAF：先实现 L1/L2/L3（三层就能出论文）
* 理解锁：做 2 种题型（预测型+变体型）

这样实现成本可控，但论文故事完整。

---

如果你愿意，我下一步可以把这套机制进一步“工程化”为：

* **特征清单 + 阈值建议**（PSW 判定规则）
* **诊断 prompt 模板**（让 LLM 输出可解释的四分类）
* **每个层级 L0–L4 的标准化输出格式**（方便前端渲染）
* **实验对比设计**（三组对比 + 学习指标）


